// Copyright 2016 theaigames.com (developers@theaigames.com)

//    Licensed under the Apache License, Version 2.0 (the "License");
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at

//        http://www.apache.org/licenses/LICENSE-2.0

//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an "AS IS" BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.
//
//    For the full copyright and license information, please view the LICENSE
//    file that was distributed with this source code.

package com.theaigames.game;

import com.theaigames.engine.Engine;
import com.theaigames.engine.Logic;
import com.theaigames.engine.io.IOBot;
import com.theaigames.game.player.BotPlayer;
import com.theaigames.game.player.CliBot;
import com.theaigames.game.player.Player;
import one.util.streamex.StreamEx;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.function.Function;
import java.util.stream.Collectors;

/**
 * abstract class AbstractGame
 *
 * DO NOT EDIT THIS FILE
 *
 * Extend this class with your main method. In the main method, create an
 * instance of your Logic and run setupEngine() and runEngine()
 *
 * @author Jim van Eeden <jim@starapple.nl>
 */

public abstract class AbstractGame implements Logic {

    public Engine engine = new Engine();
    public GameHandler processor;

    public int maxRounds;

    public boolean DEV_MODE = false; // turn this on for local testing
    public String TEST_BOT; // command for the test bot in DEV_MODE
    public int NUM_TEST_BOTS; // number of bots for this game

    public AbstractGame() {
        maxRounds = -1; // set this later if there is a maximum amount of rounds for this game
    }

    protected abstract long getTimeBankMax();
    protected abstract long getTimePerMove();

    /**
     * Partially sets up the engine
     * @param args : command line arguments passed on running of application
     */
    public void setupEngine(String[] args) throws IOException {
        if (DEV_MODE) {
            initDevMode();
            return;
        }

        List<CliBot> bots = parseBots(args);

        setupEngine(bots);
    }

    public void setupEngine(List<CliBot> bots) {
        // create engine
        this.engine = new Engine();

        // add the players
        bots.forEach(bot -> this.engine.addPlayer(createPlayer(bot)));
    }

    public void setupEngine(Collection<? extends Player> players) {
        // create engine
        this.engine = new Engine();

        // add the players
        players.forEach(engine::addPlayer);
    }

    private List<CliBot> parseBots(String[] args) {
        ArgsParser argsParser = ArgsParser.parse(args);

        List<String> botIds = argsParser.getBotIds();
        List<String> botDirs = argsParser.getBotDirs();

        // check if the starting arguments are passed correctly
        if (botIds.isEmpty() || botDirs.isEmpty() || (botIds.size() != botDirs.size())) {
            throw new RuntimeException("Missing some arguments.");
        }


        return StreamEx.zip(botDirs, botIds, this::createBot).collect(Collectors.toList());
    }

    private CliBot createBot(String command, String id) {
        try {
            Process process = Runtime.getRuntime().exec(command);
            return new IOBot(process, id);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    private BotPlayer createPlayer(CliBot bot) {
        return new BotPlayer(bot.getId(), bot, getTimeBankMax(), getTimePerMove());
    }

    private BotPlayer createPlayer(String botCommand, int id) {
        return createPlayer(createBot(botCommand, "ID_" + id));
    }

    private void initDevMode() throws IOException {

        // create engine
        this.engine = new Engine();

        if (TEST_BOT.isEmpty()) {
            throw new RuntimeException("DEV_MODE: Please provide a command to start the test bot " +
                    "by setting 'TEST_BOT' in your main class.");
        }
        if (NUM_TEST_BOTS <= 0) {
            throw new RuntimeException("DEV_MODE: Please provide the number of bots in this game " +
                    "by setting 'NUM_TEST_BOTS' in your main class.");
        }

        for (int i = 0; i < NUM_TEST_BOTS; i++) {
            this.engine.addPlayer(createPlayer(TEST_BOT, i));
        }
    }

    /**
     * Implement this class. Set logic in the engine and start it to run the game
     */
    protected abstract void runEngine() throws Exception;

    /**
     * @return : True when the game is over
     */
    @Override
    public boolean isGameOver()
    {
        return this.processor.isGameOver()
                || (this.maxRounds >= 0 && this.processor.getRoundNumber() > this.maxRounds);
    }

    /**
     * Play one round of the game
     * @param roundNumber : round number
     */
    @Override
    public void playRound(int roundNumber)
    {
        for (Player player : this.engine.getPlayers())
            player.addToDump(String.format("Round %d", roundNumber));

        this.processor.playRound(roundNumber);
    }

    /**
     * close the bot processes, save, exit program
     */
    @Override
    public void finish() throws InterruptedException {
        // stop the bots
        for (Player player : this.engine.getPlayers()) {
            player.finish();
        }

        Thread.sleep(100L);

        if (DEV_MODE) { // print the game file when in DEV_MODE
            String playedGame = this.processor.getPlayedGame();
            System.out.println(playedGame);
        } else { // save the game to database
            try {
                this.saveGame();
            } catch(Exception e) {
                e.printStackTrace();
            }
        }

        System.out.println("Done.");

        System.exit(0);
    }

    /**
     * Does everything that is needed to store the output of a game
     */
    public void saveGame() {

        // save results to file here
        String playedGame = this.processor.getPlayedGame();
        System.out.println(playedGame);
    }

    private static final class ArgsParser {
        private final List<String> botDirs;
        private final List<String> botIds;

        private ArgsParser(List<String> botDirs, List<String> botIds) {
            this.botDirs = new ArrayList<>(botDirs);
            this.botIds = new ArrayList<>(botIds);
        }


        List<String> getBotDirs() {
            return botDirs;
        }

        List<String> getBotIds() {
            return botIds;
        }

        static ArgsParser parse(String... args) {
            List<String> ids = new ArrayList<>();
            List<String> dirs = new ArrayList<>();

            if (args.length <= 0) {
                throw new RuntimeException("No arguments provided.");
            }

            for (int i=0; i < args.length; i++) {
                ids.add(i + "");
                dirs.add(args[i]);
            }

            return new ArgsParser(dirs, ids);
        }
    }

    @FunctionalInterface
    private interface FunctionWithException<F, T> extends Function<F, T> {

        @Override
        default T apply(F from) {
            try {
                return applyWithException(from);
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        }

        T applyWithException(F from) throws Exception;
    }
}
